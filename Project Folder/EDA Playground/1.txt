// reram_core_tb.sv
// Testbench for the reram_core module

`timescale 1ns / 1ps

module reram_core_tb; // No inputs/outputs, it's a self-contained test environment

    // Testbench specific parameters (can be adjusted for faster/slower tests)
    localparam TB_ROWS = 4;
    localparam TB_COLS = 4;
    localparam TB_ADDR_WIDTH = $clog2(TB_ROWS * TB_COLS);
    localparam TB_LRS_VAL = 1'b0;
    localparam TB_HRS_VAL = 1'b1;
    localparam TB_CELL_SET_DELAY_CYCLES = 5;
    localparam TB_CELL_RESET_DELAY_CYCLES = 5;
    localparam TB_CELL_ENDURANCE_LIMIT = 10;

    // Testbench internal signals (registers for inputs, wires for outputs)
    reg clk;
    reg rst_n;
    localparam CLK_PERIOD = 10000; // 10,000 ps = 10 ns clock period (100 MHz)

    reg [TB_ADDR_WIDTH-1:0] tb_addr;
    reg tb_data_in;
    reg tb_write_en;
    reg tb_read_en;

    wire tb_data_out;
    wire tb_busy;
    wire [TB_ROWS*TB_COLS-1:0] tb_all_failed_cells;

    // Instantiate the Unit Under Test (UUT) - our reram_core
    reram_core #(
        .ROWS(TB_ROWS),
        .COLS(TB_COLS),
        .ADDR_WIDTH(TB_ADDR_WIDTH),
        .LRS_VAL(TB_LRS_VAL),
        .HRS_VAL(TB_HRS_VAL),
        .CELL_SET_DELAY_CYCLES(TB_CELL_SET_DELAY_CYCLES),
        .CELL_RESET_DELAY_CYCLES(TB_CELL_RESET_DELAY_CYCLES),
        .CELL_ENDURANCE_LIMIT(TB_CELL_ENDURANCE_LIMIT)
    ) u_reram_core (
        .clk(clk),
        .rst_n(rst_n),
        .addr(tb_addr),
        .data_in(tb_data_in),
        .write_en(tb_write_en),
        .read_en(tb_read_en),
        .data_out(tb_data_out),
        .busy(tb_busy),
        .all_failed_cells(tb_all_failed_cells)
    );

    // Clock generation (runs concurrently with all other initial/always blocks)
    initial begin
        clk = 0; // Initialize clock to 0
        forever #((CLK_PERIOD / 2)) clk = ~clk; // Toggle clock every half period
    end

    // Waveform dumping for debugging with GTKWave (or similar)
    initial begin
        $dumpfile("dump.vcd");
        $dumpvars(0, reram_core_tb); // Dump all signals in this module and its hierarchy
    end

    // Test stimulus (sequential actions within this initial block)
    initial begin
        // 1. Initial Reset sequence
        rst_n = 1'b0; // Assert reset (active low)
        tb_write_en = 1'b0; // No write
        tb_read_en = 1'b0;  // No read
        tb_addr = 0;        // Default address
        tb_data_in = TB_HRS_VAL; // Default data (High Resistance State)
        #(CLK_PERIOD * 2);  // Hold reset for 2 clock cycles
        rst_n = 1'b1;       // De-assert reset
        #(CLK_PERIOD * 2);  // Wait a few cycles after reset for stability

        $display("--- Starting ReRAM Core Test ---"); // Print message to console

        // 2. Write to Address 0 (Set to LRS = 0)
        $display("Time %0t: Requesting Write LRS to Address 0 (Target: %b)...", $time, TB_LRS_VAL);
        tb_addr = 0;          // Set address
        tb_data_in = TB_LRS_VAL; // Set data to LRS (0)
        tb_write_en = 1'b1;   // Assert write enable
        @(posedge clk);      // Latch inputs into reram_core.core_fsm_state (IDLE -> START_WRITE)
        @(posedge clk);      // Latch inputs into reram_cell, cell FSM starts, busy goes high
        tb_write_en = 1'b0;   // De-assert write enable
        // NEW: Wait for core to become not busy, which implies cell is also not busy
        while (tb_busy) @(posedge clk); // Wait until the core (and thus the cell) is no longer busy

        @(posedge clk);      // Wait one more clock cycle for read_data to update after write completes
        $display("Time %0t: Write LRS to Addr 0 completed. Current data from Addr 0: %b (Expected: %b)", $time, tb_data_out, TB_LRS_VAL);

        // 3. Read from Address 0 (explicitly)
        $display("Time %0t: Explicitly Reading from Address 0...", $time);
        tb_addr = 0;        // Ensure address is 0
        tb_read_en = 1'b1;  // Assert read enable
        @(posedge clk);     // Latch address, read_data updates combinationaly
        tb_read_en = 1'b0;  // De-assert read enable
        $display("Time %0t: Read data from Addr 0: %b (Expected: %b)", $time, tb_data_out, TB_LRS_VAL);
        #(CLK_PERIOD);      // Wait for a full clock period

        // 4. Write to Address 1 (Set to LRS = 0)
        $display("Time %0t: Requesting Write LRS to Address 1 (Target: %b)...", $time, TB_LRS_VAL);
        tb_addr = 1;
        tb_data_in = TB_LRS_VAL;
        tb_write_en = 1'b1;
        @(posedge clk);
        @(posedge clk);
        tb_write_en = 1'b0;
        while (tb_busy) @(posedge clk);
        @(posedge clk); // Wait one more cycle
        $display("Time %0t: Write LRS to Addr 1 completed. Current data from Addr 1: %b (Expected: %b)", $time, tb_data_out, TB_LRS_VAL);

        // 5. Read from Address 1 (to confirm)
        $display("Time %0t: Reading from Address 1...", $time);
        tb_addr = 1;
        tb_read_en = 1'b1;
        @(posedge clk);
        tb_read_en = 1'b0;
        $display("Time %0t: Read data from Addr 1: %b (Expected: %b)", $time, tb_data_out, TB_LRS_VAL);
        #(CLK_PERIOD);

        // 6. Write to Address 0 (Reset to HRS = 1)
        $display("Time %0t: Requesting Write HRS to Address 0 (Target: %b)...", $time, TB_HRS_VAL);
        tb_addr = 0;
        tb_data_in = TB_HRS_VAL;
        tb_write_en = 1'b1;
        @(posedge clk);
        @(posedge clk);
        tb_write_en = 1'b0;
        while (tb_busy) @(posedge clk);
        @(posedge clk); // Wait one more cycle
        $display("Time %0t: Write HRS to Addr 0 completed. Current data from Addr 0: %b (Expected: %b)", $time, tb_data_out, TB_HRS_VAL);

        // 7. Read from Address 0 (to confirm)
        $display("Time %0t: Reading from Address 0...", $time);
        tb_addr = 0;
        tb_read_en = 1'b1;
        @(posedge clk);
        tb_read_en = 1'b0;
        $display("Time %0t: Read data from Addr 0: %b (Expected: %b)", $time, tb_data_out, TB_HRS_VAL);
        #(CLK_PERIOD);

        // 8. Test Endurance on Address 0
        $display("Time %0t: Starting endurance test on Address 0 (Limit: %0d)...", $time, TB_CELL_ENDURANCE_LIMIT);
        tb_addr = 0;
        for (integer i = 0; i < TB_CELL_ENDURANCE_LIMIT + 5; i = i + 1) begin // Loop beyond limit
            tb_data_in = (i % 2 == 0) ? TB_LRS_VAL : TB_HRS_VAL; // Alternate LRS/HRS writes
            tb_write_en = 1'b1;
            @(posedge clk); // Latch inputs, Core FSM reacts (IDLE -> START_WRITE)
            @(posedge clk); // Core FSM reacts (START_WRITE -> WAIT_WRITE_COMPLETE), Cell FSM starts, busy goes high
            tb_write_en = 1'b0;
            while (tb_busy) @(posedge clk); // Wait for the cell to finish its operation via core busy signal
            @(posedge clk); // Wait one more cycle for data_out_reg to update

            // Optional: Read after each write to check current state
            tb_read_en = 1'b1;
            @(posedge clk); // Give one clock cycle for internal_addr_reg to update for read
            tb_read_en = 1'b0;
            $display("Time %0t: Write %0d to Addr %0d (Target: %b), Read: %b, Cell 0 Failed: %b",
                      $time, i+1, tb_addr, tb_data_in, tb_data_out, tb_all_failed_cells[0]);
            #(CLK_PERIOD);
        end

        // 9. Check final status of Address 0
        $display("Time %0t: Final check on Address 0 - Failed status: %b", $time, tb_all_failed_cells[0]);

        $display("--- ReRAM Core Test Complete ---");
        $finish; // End simulation
    end

endmodule


// reram_cell.sv
// Basic behavioral model for a single ReRAM cell

`timescale 1ns / 1ps

module reram_cell #(
    parameter LRS_STATE = 1'b0,
    parameter HRS_STATE = 1'b1,
    parameter SET_DELAY_CYCLES = 10,  // Example: 10 clock cycles for SET
    parameter RESET_DELAY_CYCLES = 10, // Example: 10 clock cycles for RESET
    parameter ENDURANCE_LIMIT = 1000 // Example: 1000 write cycles
) (
    input wire clk,
    input wire rst_n, // Active low reset

    input wire write_en,      // Assert to initiate a write
    input wire target_state,  // Desired state (LRS_STATE or HRS_STATE)
    output reg read_data,    // Current state of the cell (CHANGED TO REG)

    output wire busy,         // Indicates cell is undergoing a write operation
    output wire failed        // Indicates cell has reached endurance limit
);

    // Internal state of the ReRAM cell (LRS_STATE or HRS_STATE)
    reg current_state;

    // Counter for set/reset delays
    reg [31:0] delay_counter; // Large enough for various delay cycles

    // State machine for write operations (IDLE, SETTING, RESETTING)
    // IMPORTANT FIX: Moved these localparam declarations here for iverilog visibility.
    localparam IDLE = 2'b00;
    localparam SETTING = 2'b01;
    localparam RESETTING = 2'b10;
    reg [1:0] write_fsm_state;

    // Endurance counter
    reg [31:0] endurance_counter;
    reg cell_failed_flag;

    // The 'assign' statements need these localparams to be defined before them.
    assign busy = (write_fsm_state != IDLE);
    assign failed = cell_failed_flag;


    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= HRS_STATE; // Default to HRS on reset
            delay_counter <= 0;
            write_fsm_state <= IDLE;
            endurance_counter <= 0;
            cell_failed_flag <= 1'b0;
            read_data <= HRS_STATE; // Initialize registered output
            $display("Time %0t: Cell Reset! Initial State: %b, Endurance: %0d", $time, HRS_STATE, 0);
        end else begin
            // Check for cell failure due to endurance
            if (endurance_counter >= ENDURANCE_LIMIT && !cell_failed_flag) begin // Only display once when it fails
                cell_failed_flag <= 1'b1;
                $display("Time %0t: Cell FAILED! Endurance Limit (%0d) reached for cell. Endurance was %0d", $time, ENDURANCE_LIMIT, endurance_counter);
            end

            // Main write FSM
            case (write_fsm_state)
                IDLE: begin
                    if (write_en && !cell_failed_flag) begin
                        if (target_state == LRS_STATE) begin // Target is LRS
                            write_fsm_state <= SETTING;
                            delay_counter <= 0;
                            $display("Time %0t: Cell (IDLE->SETTING) for target %b. Current: %b", $time, target_state, current_state);
                        end else if (target_state == HRS_STATE) begin // Target is HRS
                            write_fsm_state <= RESETTING;
                            delay_counter <= 0;
                            $display("Time %0t: Cell (IDLE->RESETTING) for target %b. Current: %b", $time, target_state, current_state);
                        end
                    end
                end
                SETTING: begin
                    if (delay_counter < SET_DELAY_CYCLES - 1) begin
                        delay_counter <= delay_counter + 1;
                        $display("Time %0t: Cell (SETTING) Delay: %0d/%0d. Current State: %b", $time, delay_counter, SET_DELAY_CYCLES, current_state);
                    end else begin
                        current_state <= LRS_STATE; // State change happens here
                        endurance_counter <= endurance_counter + 1; // Increment on successful write completion
                        write_fsm_state <= IDLE;
                        $display("Time %0t: Cell (SETTING->IDLE) COMPLETE. New State: %b, Endurance: %0d", $time, LRS_STATE, endurance_counter + 1);
                    end
                end
                RESETTING: begin
                    if (delay_counter < RESET_DELAY_CYCLES - 1) begin
                        delay_counter <= delay_counter + 1;
                        $display("Time %0t: Cell (RESETTING) Delay: %0d/%0d. Current State: %b", $time, delay_counter, RESET_DELAY_CYCLES, current_state);
                    end else begin
                        current_state <= HRS_STATE; // State change happens here
                        endurance_counter <= endurance_counter + 1; // Increment on successful write completion
                        write_fsm_state <= IDLE;
                        $display("Time %0t: Cell (RESETTING->IDLE) COMPLETE. New State: %b, Endurance: %0d", $time, HRS_STATE, endurance_counter + 1);
                    end
                end
                default: begin // Should not happen
                    write_fsm_state <= IDLE;
                end
            endcase
            read_data <= current_state; // Continuously update registered output with current_state
        end
    end

endmodule



// reram_core.sv
// Controller for a 2D array of ReRAM cells

`timescale 1ns / 1ps

module reram_core #(
    parameter ROWS = 8,
    parameter COLS = 8,
    parameter ADDR_WIDTH = $clog2(ROWS * COLS), // Calculate address width needed
    parameter LRS_VAL = 1'b0,
    parameter HRS_VAL = 1'b1,
    parameter CELL_SET_DELAY_CYCLES = 10,
    parameter CELL_RESET_DELAY_CYCLES = 10,
    parameter CELL_ENDURANCE_LIMIT = 1000
) (
    input wire clk,
    input wire rst_n,
    input wire [ADDR_WIDTH-1:0] addr, // Address of the cell to access
    input wire data_in,      // Data to write (0 or 1)
    input wire write_en,     // Trigger a write (from external controller)
    input wire read_en,      // Trigger a read (from external controller)
    output wire data_out,    // Data read from the selected cell
    output wire busy,        // Core is busy if a write is in progress
    output wire [ROWS*COLS-1:0] all_failed_cells // A bitmask showing which cells have failed
);

    // Internal wires to connect to the ReRAM cells (flattened 2D array into 1D)
    wire [ROWS*COLS-1:0] cell_read_data; // All cells' read outputs
    wire [ROWS*COLS-1:0] cell_busy;      // All cells' busy flags
    wire [ROWS*COLS-1:0] cell_failed;    // All cells' failed flags

    // Registers for the core's internal FSM
    reg selected_cell_write_en;   // Write enable signal to pass to the *selected* cell
    reg selected_cell_target_state; // Target state to pass to the *selected* cell
    reg [ADDR_WIDTH-1:0] current_op_addr; // Stores the address for the current operation

    // Core FSM states - ADDED CORE_START_WRITE
    localparam CORE_IDLE = 2'b00;
    localparam CORE_START_WRITE = 2'b01; // New State: Assert write_en for one cycle
    localparam CORE_WAIT_WRITE_COMPLETE = 2'b11; // Existing state, renamed/re-purposed
    localparam CORE_READING = 2'b10;
    reg [1:0] core_fsm_state;

    // Core is busy if its FSM is not IDLE
    assign busy = (core_fsm_state != CORE_IDLE);

    // The 'all_failed_cells' output directly corresponds to the 'cell_failed' array
    assign all_failed_cells = cell_failed;

    // This block generates the write_en and target_state signals for each cell.
    // By default, no cell receives write_en. Only the currently addressed cell,
    // when 'selected_cell_write_en' from the FSM is high, gets its 'write_en' asserted.
    reg [ROWS*COLS-1:0] cell_write_en_local;      // Local signal for individual cell write_en
    reg [ROWS*COLS-1:0] cell_target_state_local; // Local signal for individual cell target_state

    // Combinational logic: Updates `cell_write_en_local` and `cell_target_state_local` based on `current_op_addr`
    always_comb begin
        cell_write_en_local = '0; // Default all to 0 (no write)
        cell_target_state_local = '0; // Default all to 0

        // If core controller decides to write and address is valid, activate signals for that specific cell
        if (selected_cell_write_en && current_op_addr < (ROWS * COLS)) begin
            cell_write_en_local[current_op_addr] = 1'b1; // Assert write_en for the selected cell
            cell_target_state_local[current_op_addr] = selected_cell_target_state; // Pass target state
        end
    end

    // This `generate` block instantiates (creates) all the individual ReRAM cells.
    genvar row_idx, col_idx; // Loop variables for generate block (compile-time constants)
    for (row_idx = 0; row_idx < ROWS; row_idx = row_idx + 1) begin : row_inst
        for (col_idx = 0; col_idx < COLS; col_idx = col_idx + 1) begin : col_inst
            localparam CELL_INDEX = row_idx * COLS + col_idx; // Calculate the 1D index for this cell

            // Instantiate a single ReRAM cell
            reram_cell #(
                .LRS_STATE(LRS_VAL),
                .HRS_STATE(HRS_VAL),
                .SET_DELAY_CYCLES(CELL_SET_DELAY_CYCLES),
                .RESET_DELAY_CYCLES(CELL_RESET_DELAY_CYCLES),
                .ENDURANCE_LIMIT(CELL_ENDURANCE_LIMIT)
            ) u_reram_cell ( // Name of this specific cell instance
                .clk(clk),
                .rst_n(rst_n),
                .write_en(cell_write_en_local[CELL_INDEX]),    // Connect to the local write_en signal
                .target_state(cell_target_state_local[CELL_INDEX]), // Connect to the local target_state signal
                .read_data(cell_read_data[CELL_INDEX]),        // Connect to the cell's output
                .busy(cell_busy[CELL_INDEX]),                  // Connect to the cell's busy flag
                .failed(cell_failed[CELL_INDEX])                // Connect to the cell's failed flag
            );
        end
    end

    // Combinational logic for the data_out (read data)
    reg data_out_reg; // Internal register to hold the read data
    assign data_out = data_out_reg; // Connect the register to the output wire

    always_comb begin
        data_out_reg = HRS_VAL; // Default value (e.g., if address invalid)
        // If the address is within bounds, read the data from the corresponding cell
        if (current_op_addr < (ROWS * COLS)) begin
            data_out_reg = cell_read_data[current_op_addr]; // Read from the selected cell
        end
    end

    // Main Controller FSM (Sequential Logic)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin // Reset condition
            core_fsm_state <= CORE_IDLE;
            current_op_addr <= 0;
            selected_cell_write_en <= 1'b0;
            selected_cell_target_state <= 1'b0;
        end else begin // Normal operation
            case (core_fsm_state)
                CORE_IDLE: begin // Core is ready for new command
                    selected_cell_write_en <= 1'b0; // Ensure no write is currently active

                    if (write_en) begin // If write command received
                        current_op_addr <= addr; // Latch the address
                        selected_cell_target_state <= data_in; // Latch the data to write
                        core_fsm_state <= CORE_START_WRITE; // Move to START_WRITE state
                    end else if (read_en) begin // If read command received
                        current_op_addr <= addr; // Latch the address
                        core_fsm_state <= CORE_READING; // Move to READING state
                    end
                end
                CORE_START_WRITE: begin // NEW STATE: Assert write_en for one cycle
                    selected_cell_write_en <= 1'b1; // Assert write_en
                    // Transition to a wait state, giving the cell one clock cycle to react to write_en
                    core_fsm_state <= CORE_WAIT_WRITE_COMPLETE;
                end
                CORE_WAIT_WRITE_COMPLETE: begin // Core is waiting for the cell to finish writing
                    selected_cell_write_en <= 1'b1; // Keep write_en asserted for the cell

                    // Check if the selected cell is no longer busy
                    // This check happens AFTER reram_cell has had a chance to react and go busy
                    if (current_op_addr < (ROWS * COLS) && !cell_busy[current_op_addr]) begin
                        core_fsm_state <= CORE_IDLE; // Cell finished, go back to IDLE
                        selected_cell_write_en <= 1'b0; // De-assert write_en
                    end
                end
                CORE_READING: begin // Core is performing a read
                    // Read is combinational, data_out is already set by the always_comb block
                    core_fsm_state <= CORE_IDLE; // Ready immediately after latching address
                end
                default: begin
                    core_fsm_state <= CORE_IDLE;
                end
            endcase
        end
    end

endmodule